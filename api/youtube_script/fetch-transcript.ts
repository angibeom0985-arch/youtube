import type { VercelRequest, VercelResponse } from '@vercel/node';
import { Innertube } from 'youtubei.js';

const extractVideoId = (url: string): string | null => {
  const patterns = [
    /(?:v=|\/v\/|youtu\.be\/|\/shorts\/)([A-Za-z0-9_-]{11})/,
    /^([A-Za-z0-9_-]{11})$/,
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match && match[1]) return match[1];
  }
  return null;
};

export default async function handler(req: VercelRequest, res: VercelResponse) {
  if (req.method === 'OPTIONS') {
    res.status(200).end();
    return;
  }

  if (req.method !== 'POST') {
    res.status(405).send('Method not allowed');
    return;
  }

  try {
    const url = (req.body as any)?.url as string;
    if (!url || !url.trim()) {
      res.status(400).send('URL이 필요합니다.');
      return;
    }

    const videoId = extractVideoId(url.trim());
    if (!videoId) {
      res.status(400).send('올바른 유튜브 URL이 아닙니다.');
      return;
    }

    console.log(`[fetch-transcript] Fetching transcript for video: ${videoId}`);

    const youtube = await Innertube.create();
    const info = await youtube.getInfo(videoId);
    
    if (!info.captions) {
        res.status(404).send('이 영상에 자막이 존재하지 않습니다.');
        return;
    }

    const caption_tracks = info.captions.caption_tracks;
    if (!caption_tracks || caption_tracks.length === 0) {
        res.status(404).send('자막 트랙을 찾을 수 없습니다.');
        return;
    }

    // 1. 한국어 자막 찾기 (수동 -> 자동 순)
    let selectedTrack = caption_tracks.find(t => t.language_code === 'ko' && !t.is_kind_asr);
    if (!selectedTrack) {
        selectedTrack = caption_tracks.find(t => t.language_code === 'ko');
    }

    // 2. 한국어 없으면 영어 자막 찾기
    if (!selectedTrack) {
        selectedTrack = caption_tracks.find(t => t.language_code === 'en' && !t.is_kind_asr);
        if (!selectedTrack) {
            selectedTrack = caption_tracks.find(t => t.language_code === 'en');
        }
    }

    // 3. 그것도 없으면 첫 번째 자막 사용
    if (!selectedTrack) {
        selectedTrack = caption_tracks[0];
    }

    console.log(`[fetch-transcript] Selected track: ${selectedTrack.name.text} (${selectedTrack.language_code})`);

    const transcriptData = await info.getTranscript(selectedTrack.language_code);
    const transcriptItems = transcriptData.transcript.content?.body?.initial_segments;

    if (!transcriptItems || transcriptItems.length === 0) {
      res.status(404).send('자막 데이터를 가져오지 못했습니다.');
      return;
    }

    const fullText = transcriptItems
      .map((item: any) => item.snippet.text)
      .join(' ')
      .replace(/&amp;/g, '&')
      .replace(/&quot;/g, '"')
      .replace(/&#39;/g, "'")
      .replace(/&lt;/g, '<')
      .replace(/&gt;/g, '>')
      .replace(/\s+/g, ' ')
      .trim();

    res.status(200).json({ 
      text: fullText,
      language: selectedTrack.language_code,
      videoId: videoId,
      isAutoGenerated: selectedTrack.is_kind_asr
    });

  } catch (error: any) {
    console.error('[fetch-transcript] error:', error);
    res
      .status(500)
      .send(error?.message || '대본을 불러오는 중 오류가 발생했습니다.');
  }
}